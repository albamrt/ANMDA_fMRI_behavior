---
title: ''
output: html_document
---
```{r include = FALSE}
require(knitr)
opts_knit$set(root.dir=normalizePath('../'))
knitr::opts_chunk$set(echo = FALSE, fig.align='center', fig.pos = 'H', message = FALSE, warning = FALSE)
options(knitr.kable.NA = '')
```

```{r}
load("data/preproc_data.RData")
source('helpers/helpers.R')
source('helpers/settings.R')
```

```{r message = FALSE}
Sigma <- seq(0.1, 1.8, by = 0.05)
```

```{r eval = TRUE}
#Cross-validation to find hyperparameter sigma
n_reps <- 1000
sim <- data %>%
  group_by(group) %>%
  nest() %>%
  mutate(cv_dog1 = map(data, function(df) sapply(Sigma, 
      function(x) replicate(n_reps, crossValSigma(x, df, derivative = 1)))),
         cv_dog3 = map(data, function(df) sapply(Sigma, 
      function(x) replicate(n_reps, crossValSigma(x, df, derivative = 3)))))
save(sim, file = "data/sim-by-group.RData")
```

```{r fig.cap = 'Top: Mean squared error for stratified hyperparameter optimization using cross-validation (1,000 repetitions, training set size = .33 from each subject) for first (black) and third (orange) derivative-of-Gaussian fits. Hyperparameters are different values of scale parameter σ of the underlying Gaussian with location hyperparameter μ = 0. Bottom: Shape of first- and third-derivative-of-Gaussian fits with optimal hyperparameter σ and μ = 0.', results = 'hide'}

load(file = 'data/sim-by-group.RData')

diffstims <- seq(-pi/2, pi/2, length.out = 30)

simm <- sim %>%
  mutate(mean_MSE1 = map(.x = cv_dog1, .f = function(df) apply(df, 2, mean)),
         min_MSE1 = map_dbl(.x = mean_MSE1, .f = min),
         sigma1 = map_dbl(.x = mean_MSE1, .f = function(mMSE) Sigma[mMSE == min_MSE1]),
         mean_MSE3 = map(.x = cv_dog3, .f = function(df) apply(df, 2, mean)),
         min_MSE3 = map_dbl(.x = mean_MSE3, .f = min),
         sigma3 = map_dbl(.x = mean_MSE3, .f = function(mMSE) Sigma[mMSE == min_MSE3]),
         DoG1 = map(.x = sigma1, .f = function(s) dog1(sigma = s, x = diffstims)),
         DoG3 = map(.x = sigma3, .f = function(s) dog3(sigma = s, x = diffstims)))

#simm$DoG1 <- lapply(simm$DoG1, function(x) if(x[6]>0) return(x*-1) else x)
#simm$DoG3 <- lapply(simm$DoG3, function(x) if(x[6]>0) return(x*-1) else x)

# par(mfrow = c(1, 2))
# plot(Sigma, mean_MSE, type = 'l', 
#      ylim = c(min(c(mean_MSE, mean_MSE3)), max((c(mean_MSE, mean_MSE3)))),
#      xlab = bquote(sigma), ylab = 'MSE')
# lines(Sigma, mean_MSE3, col = 'orange')
# 
# plot(diffstims, DoG, type = 'l', 
#      ylim = c(min(na.omit(c(DoG, DoG3))), max(na.omit((c(DoG, DoG3))))))
# lines(diffstims, DoG3, col = 'orange')

p1 <- list()
p2 <- list()
ylims <- c(min(c(simm$cv_dog1[[1]], simm$cv_dog1[[2]], simm$cv_dog1[[3]])), 
           max(c(simm$cv_dog1[[1]], simm$cv_dog1[[2]], simm$cv_dog1[[3]])))
for (i in c(1:3)){
  
  print(i)
  Sim <- as.data.frame(simm$cv_dog1[[i]])
  colnames(Sim) <- paste(Sigma)
  Sim_long <- gather(Sim, sigma, MSE, c(colnames(Sim)[1]:colnames(Sim)[length(colnames(Sim))]), factor_key=TRUE)
  Sim3 <- as.data.frame(simm$cv_dog3[[i]])
  colnames(Sim3) <- paste(Sigma)
  Sim3_long <- gather(Sim3, sigma, MSE,
                      c(colnames(Sim3)[1]:colnames(Sim)[length(colnames(Sim3))]),
                      factor_key=TRUE)
p1[[i]] <- ggplot(Sim_long, aes(x=sigma, y=MSE, group=1), color = 'black') +
  ylim(ylims) +
  stat_summary(fun.data = mean_se, geom = "ribbon",
               fill = "black", alpha = 0.4) + 
  stat_summary(fun = mean, geom = "line", lwd = 1, color = 'black') + 
  stat_summary(data = Sim3_long, fun.data = mean_se, geom = "ribbon",
               fill = "orange", alpha = 0.4) + 
  stat_summary(data = Sim3_long, fun = mean, geom = "line", 
               lwd = 1, color = 'orange') + 
  scale_x_discrete(breaks=seq(0.5, 2, 0.5)) #+ ggtitle(paste(levels(sim$group)[i]))
}

for (i in c(1:3)){
  text1 <- paste0("\u03C3=", simm$sigma1[[i]]) # \u03C3 unicode for sigma
  text2 <- paste0("\u03C3=", simm$sigma3[[i]])
  
  p2[[i]] <- data.frame('diffstims' = diffstims, 
                  'DoG' = DoG_sign(simm$DoG1[[i]]), 
                  'DoG3' = DoG_sign(simm$DoG3[[i]])) %>%
    ggplot() +
    geom_line(aes(x = diffstims, y = DoG), color = 'black') + 
    geom_line(aes(x = diffstims, y=DoG3), color = 'orange') +
    annotate("text", x = 1, y = -0.7, color = 'black', parse = TRUE,
             label = text1, size = 3) +
    annotate("text", x = 1, y = -0.9, color = 'orange', parse = TRUE,
                 label = text2, size = 3)
  #+ ggtitle(paste(levels(sim$group)[i])) 
}

subplot(subplot(p1, nrows = 1, shareY = TRUE), 
        subplot(p2, nrows = 1, shareY = TRUE), 
        nrows = 2) %>%
  layout(annotations = list(
  list(x = 0.05 , y = 1.05, text = levels(sim$group)[1], 
       showarrow = F, xref='paper', yref='paper'),
  list(x = (1/3) + 0.05 , y = 1.05, text = levels(sim$group)[2],
       showarrow = F, xref='paper', yref='paper'),
   list(x = (2/3) + 0.05 , y = 1.05, text = levels(sim$group)[3],
       showarrow = F, xref='paper', yref='paper')))
```

```{r echo = FALSE}
isFirstDoGBetter <- simm$min_MSE1 < simm$min_MSE3
isThirdDoGBetter <- simm$min_MSE3 < simm$min_MSE1
dogs <- c('first', 'third')
```

```{r results='asis'}
cat(paste0("After cross-validation we observe that for the control group we obtain the lowest MSE with the ", dogs[isFirstDoGBetter+1][1], " derivative of gaussian. For the encephalitis group the best one is the ", dogs[isFirstDoGBetter+1][2], '. And for the schizphrenia group the best one is the ', dogs[isFirstDoGBetter+1][3],' derivative of gaussian.'))
```


```{r}
# add DoG variable to data:
data$DoG <- NA
for (i in c(1:3)){
  if(simm$min_MSE1[i] < simm$min_MSE3[i]){
    if(simm$DoG1[[i]][6] >0){
      data[data$group == levels(simm$group)[i],]$DoG <- dog1(sigma = simm$sigma1[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffstim)*-1
    }else{
      data[data$group == levels(simm$group)[i],]$DoG <- dog1(sigma = simm$sigma1[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffstim)
    }
  }else{
        if(simm$DoG3[[i]][6] >0){
      data[data$group == levels(simm$group)[i],]$DoG <- dog3(sigma = simm$sigma3[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffstim)*-1
    }else{
      data[data$group == levels(simm$group)[i],'DoG'] <- dog3(sigma = simm$sigma3[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffstim)
    }
  }
}
```

### Serial bias

```{r}
####### MODEL - SOURCES OF VARIABILITY:
# - factor group: enc, sch, ctr 
# - the subjects in the experiment: nested to group 
# - measures along time: crossed to the other 2 factors, 4 levels, fixed between-subjects factor  
# - bias of each subject (DoG), crossed to the other 3 factors, 4 levels, fixed between-subjects factor  
# - any other non-controlled variability source is captured by the error term

models <- list()

# no random factors:
models[[1]] <- lm(fourier_error ~ group*session*DoG, data, na.action = na.omit)

# random intercept model:
models[[2]] <- lme(fourier_error ~ group*time*DoG,  random = ~1|subject, 
            data, na.action = na.omit)

# random intercept model + subject nested in group:
models[[3]] <- lme(fourier_error ~ group*time*DoG,  random = ~1|group/subject, 
            data, na.action = na.omit)

# random slope for DoG:
models[[4]] <- lme(fourier_error ~ group*time*DoG,  random = ~(-1+DoG)|subject, 
            data, na.action = na.omit)

# # random slope for DoG + subject nested in group:
# models[[5]] <- lme(fourier_error ~ group*time*DoG,  
#                    random = ~(-1+DoG)|group/subject,
#                    data, na.action = na.omit)
# 
# # random slope for time:
# models[[6]] <- lme(fourier_error ~ group*time*DoG,  random = ~(-1+time)|subject, 
#             data, na.action = na.omit)
# 
# # random slope for time + subject nested in group:
# models[[7]] <- lme(fourier_error ~ group*time*DoG,  
#                    random = ~(-1+time)|group/subject, 
#                    data, na.action = na.omit)
# 
# # random intercept + random slope for DoG:
# models[[8]] <- lme(fourier_error ~ group*time*DoG,  random = ~(1+DoG)|subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for DoG + subject nested in group:
# models[[9]] <- lme(fourier_error ~ group*time*DoG, 
#                    random = ~(1+DoG)|group/subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for time:
# models[[10]] <- lme(fourier_error ~ group*time*DoG,  
#                     random = ~(1+time)|subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for time + subject nested in group:
# models[[11]] <- lme(fourier_error ~ group*time*DoG,  
#                     random = ~(1+time)|group/subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for DoG & time:
# models[[12]] <- lme(fourier_error ~ group*time*DoG,  
#                     random = ~(1+DoG+time)|subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for DoG & time + subject nested in group:
# models[[13]] <- lme(fourier_error ~ group*time*DoG,  
#                     random = ~(1+DoG+time)|group/subject, 
#             data, na.action = na.omit)
# 
# # random slope for DoG & time:
# models[[14]] <- lme(fourier_error ~ group*time*DoG, 
#                     random = ~(-1+DoG+time)|subject, 
#             data, na.action = na.omit)
# 
# # random slope for DoG & time + subject nested in group:
# models[[15]] <- lme(fourier_error ~ group*time*DoG,  
#                     random = ~(-1+DoG+time)|group/subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for DoG & time & its interaction:
# models[[16]] <- lme(fourier_error ~ group*time*DoG,  
#            random = ~(1+DoG+time+DoG:time)|subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for DoG & time & its interaction + subject nested in group:
# models[[17]] <- lme(fourier_error ~ group*time*DoG,  
#              random = ~(1+DoG+time+DoG:time)|group/subject, 
#             data, na.action = na.omit)
# 
# # random slope for DoG & time & its interaction:
# models[[18]] <- lme(fourier_error ~ group*time*DoG,  
#            random = ~(-1+DoG+time+DoG:time)|subject, 
#             data, na.action = na.omit)
# 
# # random slope for DoG & time & its interaction + subject nested in group:
# models[[19]] <- lme(fourier_error ~ group*time*DoG,  
#              random = ~(-1+DoG+time+DoG:time)|group/subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for the interaction of DoG & time:
# models[[20]] <- lme(fourier_error ~ group*time*DoG,  
#            random = ~(1+DoG+time+DoG:time)|subject, 
#             data, na.action = na.omit)
# 
# # random intercept + random slope for the interaction of DoG & time + subject nested in group:
# models[[21]] <- lme(fourier_error ~ group*time*DoG,  
#              random = ~(1+DoG+time+DoG:time)|group/subject, 
#             data, na.action = na.omit)
# 
# # random slope for the interaction of DoG & time:
# models[[22]] <- lme(fourier_error ~ group*time*DoG,  
#            random = ~(-1+DoG+time+DoG:time)|subject, 
#             data, na.action = na.omit)
# 
# # random slope for the interaction of DoG & time + subject nested in group:
# models[[23]] <- lme(fourier_error ~ group*time*DoG,  
#              random = ~(-1+DoG+time+DoG:time)|group/subject, 
#             data, na.action = na.omit)

MSE <- sapply(models, function(x) summary(x)$sigma)
AICS <- sapply(models, AIC)
#mod <- models[[which.min(AICS)]]
mod <- models[[1]]
```

The final model is:
```{r results = TRUE}
mod$call
```

With the following coefficients:
```{r}
if(is.numeric(mod$coefficients)){
  kable(mod$coefficients, digits = digits, 
        booktabs = TRUE, escape = FALSE)%>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
}
if(is.list(mod$coefficients)){
  kable(fixef(mod),  
        booktabs = TRUE, escape = FALSE, digits = 7)%>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
}
```

And the following anova table:
```{r}
kable(anova(mod), digits = digits, 
        booktabs = TRUE, escape = FALSE)%>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


```{r}
# Predictions:
mod_fit <- data.frame(x = data[,'diffstim'], group = data[, 'group'], 
                      session = data[,'session'], subject = data[,'subject'],
                      DoG = data$DoG)
mod_fit <- mod_fit[complete.cases(mod_fit),]
mod_fit$pred <- predict(mod, newdata = mod_fit, level = 0)
```

```{r warning = FALSE, fig.cap = 'Dashed lines show the mean serial bias. Shading, ± s.e.m. Solid lines show linear model fits.'}
window = pi/3
step = pi/20

gr <- split(data, 
            list(data$group, data$session), drop = TRUE)
serialbias <- lapply(gr, function(x) 
  serial_bias(prevcurr = x$diffstim, error = x$fourier_error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(serialbias, aes(x = x, y = m)) +
  geom_line(linetype = 'dashed', aes(color = group)) +
  geom_hline(yintercept=0) +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.2) +
  geom_line(data = mod_fit, aes(x = x, y = pred, color = group), size = 1) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```


```{r warning = FALSE, eval = FALSE}
data %>%
  ggplot(aes(x = diffstim, y = fourier_error), fill = group) +
  stat_smooth(aes(fill = group, color = group), linetype = 'dashed', 
              method = "loess", span = window, alpha = 0.2) +
  geom_line(data = mod_fit, aes(x = x, y = pred, color = group), size = 1) +
  geom_hline(yintercept = 0, color = "black") +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus") 
```

```{r eval = FALSE}
### Folded serial bias
```

```{r warning = FALSE, eval = FALSE, fig.cap = 'Dashed lines show the mean serial bias. Shading, ± s.e.m. Solid lines show linear model fits (with the non-folded serial bias).'}
window = pi/5
step = pi/20
foldedserialbias <- lapply(gr, function(x) 
  folded_serial_bias(prevcurr = x$diffstim, error = x$fourier_error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(foldedserialbias, aes(x = x, y = m)) +
  geom_line(linetype = 'dashed', aes(color = group)) +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.2) +
  geom_line(data = mod_fit[mod_fit$x>0,], aes(x = x, y = pred, 
                                                color = group), size = 1) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  ggtitle('Folded serial bias') + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```

```{r warning = FALSE, eval = FALSE}
data %>%
  ggplot(aes(x = abs(diffstim), y = fourier_error*sign(diffstim)), fill = group) +
  stat_smooth(aes(fill = group, color = group), method = "loess", 
              span = window, linetype = 'dashed', alpha = 0.2) +
  geom_line(data = mod_fit[mod_fit$x>0,], aes(x = x, y = pred, 
                                                color = group), size = 1) +
  geom_hline(yintercept=0, color = "black") +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) + 
  labs(x = "Difference previous - current stimulus", y = 'Error') 
```

```{r eval = FALSE}
### Mean folded serial bias by group and session
```

```{r eval = FALSE}
groupedSubjSes <- data %>%
  group_by(session, subject) %>%
  nest() %>%
  mutate(group = substr(subject, 1,1), 
         time = unlist(map(data, function(x) unique(x['session']))))  %>%
  mutate(foldedserialbias = map(.x = data, .f = function(x) 
    folded_serial_bias(prevcurr = x$diffstim, error = x$fourier_error, window = window,
                       step = step)),
    mean_folded = unlist(map(foldedserialbias, function(x) mean(x$m, na.rm = TRUE))))

if(simm$min_MSE1 < simm$min_MSE3){
  newdat <- expand.grid(group = levels(data$group), time = unique(data$session), 
                               DoG = mean(DoG, na.rm = TRUE),
                        subject = levels(data$subject))
}else{
  newdat <- expand.grid(group = levels(data$group), time = unique(data$session), 
                               DoG3 = mean(DoG3, na.rm = TRUE),
                        subject = levels(data$subject))
}
newdat$pred <- predict(mod, newdat)
```

```{r eval = FALSE, fig.cap = 'Mean folded serial bias by subect. Its mean and error bars are also plotted. The romboid is the predicted value by the mixed model (with the non-folded serial bias).'}
groupedSubjSes %>%
  group_by(group, session) %>%
  nest() %>%
  mutate(m = unlist(map(data, function(x) mean(na.omit(x$mean_folded)))), 
         s = unlist(map(data, function(x) sd(na.omit(x$mean_folded)))),
         n = unlist(map(data, function(x) nrow(x))),
         se = s/n,
         lower = m - se,
         upper = m + se,
         width = unlist(map(data, function(x) nrow(x)*0.01)),
         time = recode(session, S1 = 0, S2 = 3/12, S3 = 6/12, S4 = 12/12, S5 = 24/12)) %>%
  group_by(time) %>%
  mutate(
    width = 0.05 * n()
  ) %>%
  ggplot(aes(x = session, y = m, color = group)) +
  geom_point(position = position_dodge(width = 0.15), shape = 3) + 
  geom_errorbar(aes(ymin = lower, ymax = upper, color = group, width = width), 
                position = position_dodge(width = 0.15)) +
  geom_point(data = groupedSubjSes, aes(x = session, y = mean_folded, 
                                        colour = group),  
             position = position_jitterdodge(dodge.width = 0.15,
                                             jitter.width = 0.05), 
             alpha = 0.3) +
  geom_hline(yintercept=0) +
  #facet_grid(vars(group)) +
  scale_color_manual(values=colors) +
  ylab('Mean folded serial bias') + 
  geom_point(aes(x = session, y = pred, color = group), data = newdat, 
             position = position_dodge(width = 0.15), shape = 9) 
```

```{r eval = FALSE}
newdat %>%
  ggplot(aes(x = session, y = pred, color = group)) +
  geom_point(position = position_dodge(width = 0.15), shape = 3) + 
  # geom_point(data = newdat, aes(x = time, y = pred, 
  #                                       colour = group),  
  #            position = position_jitterdodge(dodge.width = 0.15,
  #                                            jitter.width = 0.05), 
  #            alpha = 0.3) +
  geom_hline(yintercept = 0) +
  scale_color_manual(values=colors)

mod <- update(mod, .~., method = 'REML')
plot(ranef(mod), axes = F, pch = 16, col = 'black') 
plot(1:nrow(coef(summary(mod))), coef(summary(mod))[,1], pch = 16, col = 'black',
     axes = F)
stdErrors <- coef(summary(mod))[,2]
segments(x0 = 1:length(stdErrors), x1 = 1:length(stdErrors), 
         y0 = coef(summary(mod))[,1] - stdErrors, y1 = coef(summary(mod))[,1] + stdErrors, col = 'black')
axis(2)
abline(h = 0, col = 'gray', lty = 2)
axis(1, at = 1:length(stdErrors),
     labels = rownames(coef(summary(mod))), cex.axis = 0.7)
```

```{r eval = FALSE, fig.cap = 'Mixed model predictions.'}
coef = fixed.effects(mod) 
dog = na.omit(DoG)
mdog = mean(dog)

ctrl0 = coef['DoG']*mdog                                      
ctrl025 = coef['DoG']*mdog + coef['time']*0.25 + coef['time:DoG']*mdog*0.25               
ctrl05 = coef['DoG']*mdog + coef['time']*0.5 + coef['time:DoG']*mdog*0.5
ctrl1 = coef['DoG']*mdog + coef['time']*1 + coef['time:DoG']*mdog*1 

enc0 = coef['DoG']*mdog + coef['groupE'] + coef['groupE:DoG']*mdog                           
enc025 = coef['DoG']*mdog + coef['groupE'] + coef['time']*0.25 + 
  coef['groupE:DoG']*mdog + coef['time:DoG']*mdog*0.25 + coef['groupE:time']*0.25 + 
  coef['groupE:time:DoG']*0.25*mdog 
enc05 = coef['DoG']*mdog + coef['groupE'] + coef['time']*0.5 + 
  coef['groupE:DoG']*mdog + coef['time:DoG']*mdog*0.5 + coef['groupE:time']*0.5 + 
  coef['groupE:time:DoG']*0.5*mdog    
enc1 = coef['DoG']*mdog + coef['groupE'] + coef['time']*1 + 
  coef['groupE:DoG']*mdog + coef['time:DoG']*mdog*1 + coef['groupE:time']*1 + 
  coef['groupE:time:DoG']*1*mdog    

schz0 = coef['DoG']*mdog + coef['groupS'] + coef['groupS:DoG']*mdog                                        
schz025 = coef['DoG']*mdog + coef['groupS'] + coef['time']*0.25 + 
  coef['groupS:DoG']*mdog + coef['time:DoG']*mdog*0.25 + coef['groupS:time']*0.25 + 
  coef['groupS:time:DoG']*0.25*mdog
schz05 = coef['DoG']*mdog + coef['groupS'] + coef['time']*0.5 + 
  coef['groupS:DoG']*mdog + coef['time:DoG']*mdog*0.5 + coef['groupS:time']*0.5 + 
  coef['groupS:time:DoG']*0.5*mdog
schz1 = coef['DoG']*mdog + coef['groupS'] + coef['time']*1 + 
  coef['groupS:DoG']*mdog + coef['time:DoG']*mdog*1 + coef['groupS:time']*1 + 
  coef['groupS:time:DoG']*1*mdog

######################
######################

grps = substr(unique(data$subject), 1,1)
ctrl = grps == 'C'
enc = grps == 'E'
schz = grps == 'S'

######################
######################

# random effects
arand = random.effects(mod) 

arandctrl = arand[ctrl, 1] + arand[ctrl, 2]    
rctrl0 = ctrl0 + arandctrl                                         
rctrl025 = ctrl025 + arandctrl                
rctrl05 = ctrl05 + arandctrl     
rctrl1 = ctrl1 + arandctrl

arandenc = arand[enc, 1] + arand[enc, 2]    
renc0 = enc0 + arandenc                          
renc025 = enc025 + arandenc 
renc05 = enc05 + arandenc
renc1 = enc1 + arandenc

arandschz = arand[schz, 1] + arand[schz, 2]    
rschz0 = schz0 + arandschz                                      
rschz025 = schz0 + arandschz
rschz05 = schz0 + arandschz
rschz1 = schz0 + arandschz

##################################################################
##################################################################

require(scales)
par(mfrow = c(1,1))
ylims = c(min(c(rctrl0, rctrl025, rctrl05, rctrl1,
               renc0, renc025, renc05, renc1,
               rschz0, rschz025, rschz05, rschz1
               ), na.rm = TRUE),
         max(c(rctrl0, rctrl025, rctrl05, rctrl1,
               renc0, renc025, renc05, renc1,
               rschz0, rschz025, rschz05, rschz1
         ), na.rm = TRUE))
denom <- 50
plot(-0.05 + rnorm(sum(ctrl))/denom, rctrl0, col = alpha(colors['C'], alpha = 0.4), pch = 16,
     xlim = c(-0.1, 1.1), ylim = ylims)
points(0 + rnorm(sum(enc))/denom, renc0, col = alpha(colors['E'], alpha = 0.4), pch = 16)
points(0.05 + rnorm(sum(schz))/denom, rschz0, col = alpha(colors['S'], alpha = 0.4), pch = 16)

points(0.2 + rnorm(sum(ctrl))/denom, rctrl025, col = alpha(colors['C'], alpha = 0.4), pch = 16,
     xlim = c(0,4), 
     ylim = c(min(c(rctrl0, renc0, rschz0), na.rm = TRUE), max(c(rctrl0, renc0, rschz0), na.rm = TRUE)))
points(0.25 + rnorm(sum(enc))/denom, renc0, col = alpha(colors['E'], alpha = 0.4), pch = 16)
points(0.3 + rnorm(sum(schz))/denom, rschz0, col = alpha(colors['S'], alpha = 0.4), pch = 16)

points(0.45 + rnorm(sum(ctrl))/denom, rctrl0, col = alpha(colors['C'], alpha = 0.4), pch = 16,
       xlim = c(0,4), 
       ylim = c(min(c(rctrl0, renc0, rschz0), na.rm = TRUE), max(c(rctrl0, renc0, rschz0), na.rm = TRUE)))
points(0.5 + rnorm(sum(enc))/denom, renc0, col = alpha(colors['E'], alpha = 0.4), pch = 16)
points(0.55 + rnorm(sum(schz))/denom, rschz0, col = alpha(colors['S'], alpha = 0.4), pch = 16)


points(0.95 + rnorm(sum(ctrl))/denom, rctrl0, col = alpha(colors['C'], alpha = 0.4), pch = 16,
       xlim = c(0,4), 
       ylim = c(min(c(rctrl0, renc0, rschz0), na.rm = TRUE), max(c(rctrl0, renc0, rschz0), na.rm = TRUE)))
points(1 + rnorm(sum(enc))/denom, renc0, col = alpha(colors['E'], alpha = 0.4), pch = 16)
points(1.05 + rnorm(sum(schz))/denom, rschz0, col = alpha(colors['S'], alpha = 0.4), pch = 16)
```


### Serial bias to previous response:
```{r}
# add previousDoG variable to data:
data$previousDoG <- NA
for (i in c(1:3)){
  if(simm$min_MSE1[i] < simm$min_MSE3[i]){
    if(simm$DoG1[[i]][6] >0){
      data[data$group == levels(simm$group)[i],'previousDoG'] <- dog1(sigma = simm$sigma1[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffresp)*-1
    }else{
      data[data$group == levels(simm$group)[i],'previousDoG'] <- dog1(sigma = simm$sigma1[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffresp)
    }
  }else{
        if(simm$DoG3[[i]][6] >0){
      data[data$group == levels(simm$group)[i], 'previousDoG'] <- dog3(sigma = simm$sigma3[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffresp)*-1
    }else{
      data[data$group == levels(simm$group)[i],'previousDoG'] <- dog3(sigma = simm$sigma3[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$diffresp)
    }
  }
}

modPreviousResp <- lm(fourier_error ~ group * session * previousDoG, data = data)
```

The linear model looks like this:
```{r}
modPreviousResp$call
```

And its associated anova table is:
```{r}
kable(anova(modPreviousResp), digits = digits, booktabs = TRUE, escape = FALSE)%>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


```{r }
serialbiasprevresp <- lapply(gr, function(x) 
  serial_bias(prevcurr = x$diffresp, error = x$fourier_error, window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(serialbiasprevresp, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  labs(x = "Difference previous response - current stimulus", y = 'Error') 
```

### Serial bias to future response:
```{r}
# add previousDoG variable to data:
data$futureDoG <- NA
for (i in c(1:3)){
  if(simm$min_MSE1[i] < simm$min_MSE3[i]){
    if(simm$DoG1[[i]][6] >0){
      data[data$group == levels(simm$group)[i],'futureDoG'] <- dog1(sigma = simm$sigma1[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$difffuture)*-1
    }else{
      data[data$group == levels(simm$group)[i],'futureDoG'] <- dog1(sigma = simm$sigma1[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$difffuture)
    }
  }else{
        if(simm$DoG3[[i]][6] >0){
      data[data$group == levels(simm$group)[i],'futureDoG'] <- dog3(sigma = simm$sigma3[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$difffuture)*-1
    }else{
      data[data$group == levels(simm$group)[i],'futureDoG'] <- dog3(sigma = simm$sigma3[[i]], 
                            x = data[data$group == levels(simm$group)[i],]$difffuture)
    }
  }
}
modFuture <- lm(fourier_error ~ group * session * futureDoG, data = data)
```

The linear model looks like this:
```{r}
modFuture$call
```

And its associated anova table is:
```{r}
kable(anova(modFuture), digits = digits, booktabs = TRUE, escape = FALSE)%>%
  kable_styling(latex_options = "HOLD_position", 
                bootstrap_options = "striped", full_width = F)
```


```{r }
serialbiasfuture <- lapply(gr, function(x) 
  serial_bias(prevcurr = x$difffuture, error = x$fourier_error, 
              window = window, step = step)) %>%
  rbindlist(., idcol='id') %>%
  as.data.frame() %>%
  mutate(session = substr(id, 3, 4), group = substr(id, 1, 1)) %>%
  filter(session != 'S5') %>%
  filter(complete.cases(.))

ggplot(serialbiasfuture, aes(x = x, y = m), color = group) +
  geom_line() +
  geom_hline(yintercept=0, color = "black") +
  geom_ribbon(aes(x = x, ymin = yl, ymax = yh, fill = group), alpha = 0.4) +
  facet_grid(vars(group), vars(session)) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  labs(x = "Difference future - current stimulus", y = 'Error') 
```